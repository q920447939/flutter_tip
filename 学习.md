### 快捷键

`stf  ` 快速创建一个有状态widget

`stl`  快速创建一个无状态widget



![image-20230817201829146](F:\liming\flutter\img\image-20230817201829146.png)

在属性上按住 alt + enter ，快速创建构造方法





#### A RenderFlex overflowed by 22 pixels on the bottom.

​	包一层`SingleChildScrollView`，让你的页面可以滑动起来。 在`Scaffold`中设置`resizeToAvoidBottomInset`为false。默认为ture，防止部件被遮挡。如果使用了这个方法，如果底部有输入框，则会造成遮挡。

#### 防止  IOS 数字框输入数字时，没有返回按钮(android有)，没有的话会没办法关闭输入框

​	1.使用keyboard_actions

​	2.指定平台  ，例如代码

```dart
class MyApp extends StatelessWidget {
  
  @override
  Widget build(BuildContext context) {
    
    return MaterialApp(
      theme: ThemeData(
        platform: TargetPlatform.android
      ),
      ...
    );
  }
}
```

其次就是使用`TextInputType.number`在IOS中弹起的键盘没有小数点符号。在输入金额类型数据时，需要将`keyboardType`属性设置为`TextInputType.numberWithOptions(decimal: true)`。



#### inheritFromWidgetOfExactType(_InheritedTheme) or inheritFromElement() was called before initState() completed.

```dart
inheritFromWidgetOfExactType(_InheritedTheme) or inheritFromElement() was called before initState() completed.
When an inherited widget changes, for example if the value of Theme.of() changes, its dependent widgets are rebuilt. If the dependent widget’s reference to the inherited widget is in a constructor or an initState() method, then the rebuilt dependent widget will not reflect the changes in the inherited widget.
Typically references to inherited widgets should occur in widget build() methods. Alternatively, initialization based on inherited widgets can be placed in the didChangeDependencies method, which is called after initState and whenever the dependencies change thereafter.
```

原因：弹出一个DIalog的`showDialog`方法会调用`Theme.of(context, shadowThemeOnly: true)`，而这个方法会通过`inheritFromWidgetOfExactType`来跨组件获取Theme对象。

解决方法就是使用`addPostFrameCallback`回调方法，等待页面build完成后在请求数据：

```dart
  @override
  void initState() {
    WidgetsBinding.instance.addPostFrameCallback((_){
      /// 接口请求
    });
  }
```

